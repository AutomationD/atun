/*
 * SPDX-License-Identifier: Apache-2.0
 * SPDX-FileCopyrightText: Â© 2024 Dmitry Kireev
 */

package ssh

import (
	"fmt"
	"github.com/automationd/atun/internal/config"
	"github.com/automationd/atun/internal/logger"
	"github.com/shirou/gopsutil/v4/process"
	ssh2 "golang.org/x/crypto/ssh"
	"log"
	"net"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"syscall"
)

// TODO: Refactor GetSSHCommandArgs into separate functions

// GetPublicKey gets the public key from the private key
func GetPublicKey(path string) (string, error) {
	if !filepath.IsAbs(path) {
		var err error
		path, err = filepath.Abs(path)
		if err != nil {
			return "", err
		}
	}

	if _, err := os.Stat(path); err != nil {
		return "", fmt.Errorf("%s does not exist", path)
	}

	f, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}

	// Parse the private key
	privateKey, err := ssh2.ParsePrivateKey(f)
	if err != nil {
		return "", err
	}

	// Extract the public key from the private key
	publicKey := privateKey.PublicKey()

	// Marshal the public key to the OpenSSH format
	pubKeyBytes := ssh2.MarshalAuthorizedKey(publicKey)

	// Return the public key as a string
	return string(pubKeyBytes), nil
}

func GenerateSSHConfigFile(app *config.Atun) (string, error) {
	sshConfigContent := `# SSH over AWS Session Manager (generated by atun.io)
host i-* mi-*
ServerAliveInterval 180
ProxyCommand sh -c "aws ssm start-session --target %h --document-name AWS-StartSSHSession --parameters 'portNumber=%p'"
`

	for _, host := range app.Config.Hosts {
		logger.Debug("Host", "name", host.Name, "proto", host.Proto, "remote", host.Remote, "local", host.Local)
		sshConfigContent += fmt.Sprintf("LocalForward %d %s:%d\n", host.Local, host.Name, host.Remote)
	}

	sshConfigFilePath := GetSSHConfigFilePath(app)
	sshConfigFile, err := os.Create(sshConfigFilePath)
	//sshConfigFile, err := os.CreateTemp(os.TempDir(), "atun-ssh.config")
	if err != nil {
		logger.Error("Error creating ssh tunnel config file", "error", err)
		return "", err
	}

	defer sshConfigFile.Close()

	// Write the content to the file
	_, err = sshConfigFile.WriteString(sshConfigContent)
	if err != nil {
		return "", err
	}

	return sshConfigFile.Name(), nil
}

func GetSSMPluginStatus(app *config.Atun) (bool, error) {
	// Check if `session-manager-plugin' is started and process contains Bastion instance ID
	cmd := exec.Command("ps", "aux")
	output, err := cmd.Output()
	if err != nil {
		return false, fmt.Errorf("failed to check SSM plugin status: %w", err)
	}

	if !strings.Contains(string(output), app.Config.BastionHostID) {
		return false, nil
	}

	return true, nil
}

func GetSSHTunnelStatus(app *config.Atun) (bool, [][]string, error) {
	// TODO: Add port check too to make sure to see outrun tunnels

	bastionSockFilePath := GetBastionSockFilePath(app)

	// If a bastion socket file exists, check the tunnel status
	if _, err := os.Stat(bastionSockFilePath); !os.IsNotExist(err) {
		logger.Debug("An existing tunnel socket found", "path", bastionSockFilePath)

		// Pass "check" command to see if the socket has a valid SSH connection
		args := []string{"ssh", "-S", bastionSockFilePath, "-O", "check", ""}

		// Run the SSH command in a blocking way
		cmd := exec.Command("ssh", args...)
		cmd.Dir = app.Config.AppDir

		if app.Config.LogLevel == "debug" {
			cmd.Args = append(cmd.Args, "-vvv")
		}
		logger.Debug("Running SSH command", "command", cmd.String())
		sshMasterProcessOutput, err := cmd.CombinedOutput()
		if err != nil {
			return false, nil, fmt.Errorf("failed to check status of the tunnel (or get output from SSH command): %w", err)
		}

		if strings.Contains(string(sshMasterProcessOutput), "running") {

			var connections [][]string

			// Fill in connections with the tunnel connections from Hosts
			for _, v := range app.Config.Hosts {
				var tunnelStatus string

				logger.Debug("Host", "name", v.Name, "proto", v.Proto, "remote", v.Remote, "local", v.Local)
				// check if the v.Local port is occupied
				portUsed, processName, err := CheckPort(v.Local)
				if err != nil {
					log.Fatalf("Error checking port status: %v", err)
				}

				if portUsed && processName == "ssh" {
					tunnelStatus = "ðŸŸ¢"
					logger.Debug("Port is occupied by ssh", "port", v.Local)
				} else {
					tunnelStatus = "ðŸ”´"
					logger.Debug("Port is not used by ssh", "port", v.Local)
				}

				logger.Debug("Port status", "port", v.Local, "status", portUsed)

				connections = append(connections, []string{fmt.Sprintf("%s:%d", v.Name, v.Remote), fmt.Sprintf("127.0.0.1:%d", v.Local), tunnelStatus})

			}

			return true, connections, nil
		} else {
			logger.Debug("Master Tunnel is not running", "output", sshMasterProcessOutput)
		}

		return false, nil, nil

	}

	logger.Debug("Tunnel socket not found. Tunnel is not running", "path", bastionSockFilePath)
	return false, nil, nil
}

func StartSSHTunnel(app *config.Atun) error {
	bastionSockFilePath := GetBastionSockFilePath(app)

	args := []string{}

	// Check if the bastion socket file exists

	tunnelStatus, _, err := GetSSHTunnelStatus(app)
	if err != nil {
		return fmt.Errorf("failed to get tunnel status: %w", err)
	}

	if !tunnelStatus {
		logger.Debug("Tunnel socket not found. Creating a new one", "path", bastionSockFilePath)
		args = []string{"-M", "-t", "-S", bastionSockFilePath, "-fN"}

		// Disable strict host key checking
		if !app.Config.SSHStrictHostKeyChecking {
			args = append(args, "-o", "StrictHostKeyChecking=no")
		}

		// TODO: Add ability to support other instance types, not just AWS Linux
		args = append(args, fmt.Sprintf("%s@%s", app.Config.BastionHostUser, app.Config.BastionHostID))
		args = append(args, "-F", app.Config.SSHConfigFile)

		if _, err := os.Stat(app.Config.SSHKeyPath); !os.IsNotExist(err) {
			args = append(args, "-i", app.Config.SSHKeyPath)
		}
	}

	if app.Config.LogLevel == "debug" {
		args = append(args, "-vvv")
	}

	logger.Debug("SSH", "args", args)
	c := exec.Command("ssh", args...)
	logger.Debug("SSH command", "command", c.String())

	c.Dir = app.Config.AppDir
	os.Setenv("AWS_REGION", app.Config.AWSRegion)
	os.Setenv("AWS_PROFILE", app.Config.AWSProfile)

	// Detach the process (platform-dependent)
	c.SysProcAttr = &syscall.SysProcAttr{
		Setpgid: true, // Detach process from the parent group
	}

	//// Stream stdout and stderr
	//if app.Config.LogLevel == "debug" {
	//	// Stream output to os.Stdout and os.Stderr in real-time
	//	stdoutPipe, err := c.StdoutPipe()
	//	if err != nil {
	//		return fmt.Errorf("failed to get stdout pipe: %w", err)
	//	}
	//	stderrPipe, err := c.StderrPipe()
	//	if err != nil {
	//		return fmt.Errorf("failed to get stderr pipe: %w", err)
	//	}
	//
	//	go io.Copy(os.Stdout, stdoutPipe)
	//	go io.Copy(os.Stderr, stderrPipe)
	//} else {
	// Only display logs without streaming
	//c.Stdout = os.Stdout
	//c.Stderr = os.Stderr
	//}
	//if app.Config.LogLevel == "debug" {
	//	stdout, err := c.StdoutPipe()
	//	if err != nil {
	//		return fmt.Errorf("failed to get stdout pipe: %w", err)
	//	}
	//
	//	stderr, err := c.StderrPipe()
	//	if err != nil {
	//		return fmt.Errorf("failed to get stderr pipe: %w", err)
	//	}
	//
	//	go io.Copy(os.Stdout, stdout)
	//	go io.Copy(os.Stderr, stderr)
	//}
	// Run the command
	if err := c.Run(); err != nil {
		logger.Debug("SSH command error", "error", err)
		return fmt.Errorf("failed to run SSH process: %w", err)

		// Print stdot and stderr from the command

	}

	logger.Debug("SSH process started in the background", "pid", c.Process.Pid)

	// Disown the process if the parent process is terminating
	// This ensures the child process doesn't get terminated when the parent exits
	go func() {
		_ = c.Process.Release() // Detach the process fully
	}()

	return nil
}

// StopSSHTunnel stops the SSH tunnel and returns false if the tunnel is not running
func StopSSHTunnel(app *config.Atun) (bool, error) {
	bastionSockFilePath := GetBastionSockFilePath(app)
	tunnelConfigFilePath := GetSSHConfigFilePath(app)

	// If a bastion socket file exists, check the tunnel status
	if _, err := os.Stat(bastionSockFilePath); !os.IsNotExist(err) {
		logger.Debug("A tunnel socket from has been found", "path", bastionSockFilePath)

		args := []string{"ssh", "-S", bastionSockFilePath, "-O", "exit", ""}

		// Run the SSH command in a blocking way
		cmd := exec.Command("ssh", args...)
		logger.Debug("Running SSH command", "command", cmd.String())
		cmd.Dir = app.Config.AppDir

		if app.Config.LogLevel == "debug" {
			cmd.Args = append(cmd.Args, "-vvv")
		}

		if err := cmd.Run(); err != nil {
			return false, fmt.Errorf("failed to exit tunnel: %w", err)
		}
	}

	// Check if the bastion socket file exists and remove it if it does
	if _, err := os.Stat(tunnelConfigFilePath); err == nil {
		if err := os.Remove(tunnelConfigFilePath); err != nil {
			return false, fmt.Errorf("failed to remove bastion config file: %w", err)
		}
		logger.Debug("Removed bastion config file", "path", tunnelConfigFilePath)
	}

	tunnelActive, _, err := GetSSHTunnelStatus(app)
	if err != nil {
		return false, fmt.Errorf("failed to get tunnel status: %w", err)
	}

	if !tunnelActive {
		return tunnelActive, nil
	}

	logger.Error("Tunnel is still active. Likely a bug")
	return true, nil
}

func GetBastionSockFilePath(app *config.Atun) string {
	logger.Debug("Getting bastion socket file path", "tunnelDir", app.Config.TunnelDir, "env", app.Config.Env, "bastionHostID", app.Config.BastionHostID)

	if app.Config.BastionHostID == "" {
		logger.Debug("Can't find Bastion Host ID is not set. Assuming bastion id from existing socket file")

	}

	return path.Join(app.Config.TunnelDir, fmt.Sprintf("%s-tunnel.sock", app.Config.BastionHostID))
}

func GetSSHConfigFilePath(app *config.Atun) string {
	return path.Join(app.Config.TunnelDir, fmt.Sprintf("%s-ssh.config", app.Config.BastionHostID))
}

func GetRunningTunnels(c *config.Atun) ([]config.Config, error) {
	var runningTunnels []config.Config
	///  ssh -M -t -S /Users/dmitry/.atun/adhoc-nutcorp-dev/i-059cde3acc2a0c8eb-tunnel.sock -fN -o StrictHostKeyChecking=no ec2-user@i-059cde3acc2a0c8eb -F /var/folders/g1/g6vwr5j95c76bc5tnq0ky2t40000gn/T/atun-ssh.config647105965 -i /Users/dmitry/.ssh/id_rsa

	// Define the regex bastionInstancePattern

	// This regex is based on the cmd and args in ssh package
	sshProcessPattern := regexp.MustCompile(`.*-S\s+(?P<sshSocketFile>\S+).*\s+(?P<userName>[a-zA-Z_][a-zA-Z0-9._-]{0,31})@(?P<instanceId>i-[0-9a-f]{17}).*-F\s+(?P<sshConfigFile>\S+).*-i\s+(?P<sshKeyPath>\S+).*`)

	// Run the ps command to list all processes
	targetBinary := "ssh" // The binary name to match exactly

	// Get a list of all processes
	processes, err := process.Processes()
	if err != nil {
		log.Fatalf("Error retrieving processes: %v", err)
	}

	logger.Debug("Process matching binary", "targetBinary", targetBinary)
	for _, proc := range processes {
		// Get process name
		name, err := proc.Name()
		if err != nil {
			continue // Skip processes with inaccessible names
		}

		// Check for an exact match of the binary name
		if strings.EqualFold(strings.TrimSpace(name), targetBinary) {
			// Get process ID
			pid := proc.Pid

			// (Optional) Get full executable path
			exePath, err := proc.Exe()
			if err != nil {
				exePath = "N/A"
			}

			a, err := proc.CmdlineSlice()
			if err != nil {
				logger.Debug("Error getting process arguments, setting empty []string{}", "error", err)
				a = []string{}
			}

			args := strings.Join(a, " ")

			logger.Debug("Found process", "pid", pid, "name", name, "exePath", exePath)
			if sshProcessPattern.MatchString(args) {
				matches := sshProcessPattern.FindStringSubmatch(args)
				if matches == nil {
					continue
				}

				matchedSSHSocketFile := ""
				matchedUserName := ""
				matchedInstanceID := ""
				matchedSSHConfigFile := ""

				for i, name := range sshProcessPattern.SubexpNames() {
					switch name {
					case "sshSocketFile":
						matchedSSHSocketFile = matches[i]
					case "userName":
						matchedUserName = matches[i]
					case "instanceId":
						matchedInstanceID = matches[i]
					case "sshConfigFile":
						matchedSSHConfigFile = matches[i]
					}
				}

				runningTunnels = append(runningTunnels, config.Config{
					SSHConfigFile:   matchedSSHConfigFile,
					SSHSocketFile:   matchedSSHSocketFile,
					BastionHostID:   matchedInstanceID,
					BastionHostUser: matchedUserName,
				})
			}
		}
	}
	return runningTunnels, nil
}

// TestSSHConnection tries to establish an SSH connection to the bastion host
func TestSSHConnection(app *config.Atun) error {
	bastionSockFilePath := GetBastionSockFilePath(app)

	args := []string{"-S", bastionSockFilePath, "-O", "check", fmt.Sprintf("%s@%s", app.Config.BastionHostUser, app.Config.BastionHostID)}

	cmd := exec.Command("ssh", args...)
	cmd.Dir = app.Config.AppDir

	if app.Config.LogLevel == "debug" {
		cmd.Args = append(cmd.Args, "-vvv")
	}

	logger.Debug("Running SSH command", "command", cmd.String())
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to establish SSH connection: %w", err)
	}

	if strings.Contains(string(output), "Master running") {
		logger.Debug("Test SSH connection established successfully")
		return nil
	}

	return fmt.Errorf("test SSH connection failed to establish: %s", output)
}

// CheckPort checks if the port is occupied and returns true/false and also process name
func CheckPort(port int) (bool, string, error) {
	logger.Debug("Checking port", "port", port)
	addr, err := net.ResolveTCPAddr("tcp", fmt.Sprintf("127.0.0.1:%v", port))
	if err != nil {
		return false, "", fmt.Errorf("can't resolve address: %w", err)
	}

	conn, err := net.DialTCP("tcp", nil, addr)
	if err != nil {
		if opErr, ok := err.(*net.OpError); ok && opErr.Op == "dial" {
			// Port is not open
			return false, "", nil
		}
		return false, "", fmt.Errorf("error dialing TCP: %w", err)
	}
	defer conn.Close()

	// Check which process has created the socket
	pid, err := getProcessIDByPort(port)
	if err != nil {
		return true, "", fmt.Errorf("error getting process ID: %w", err)
	}

	processName, err := getProcessNameByPID(pid)
	if err != nil {
		return true, "", fmt.Errorf("error getting process name: %w", err)
	}

	return true, processName, nil
}

func getProcessIDByPort(port int) (int, error) {
	cmd := exec.Command("lsof", "-sTCP:LISTEN", "-i", fmt.Sprintf(":%d", port), "-t")
	output, err := cmd.Output()
	if err != nil {
		return 0, err
	}

	pidStr := strings.TrimSpace(string(output))
	if pidStr == "" {
		return 0, fmt.Errorf("no process found for port %d", port)
	}

	pid, err := strconv.Atoi(pidStr)
	if err != nil {
		return 0, err
	}

	return pid, nil
}

func getProcessNameByPID(pid int) (string, error) {
	proc, err := process.NewProcess(int32(pid))
	if err != nil {
		return "", err
	}

	name, err := proc.Name()
	if err != nil {
		return "", err
	}

	return name, nil
}

// getBastionHostIDFromSocket gets the bastion host ID from the bastion socket file
func GetBastionHostIDFromExistingSession(tunnelDir string) (string, error) {
	files, err := os.ReadDir(tunnelDir)
	if err != nil {
		return "", fmt.Errorf("failed to read tunnel directory: %w", err)
	}

	var tunnelFiles []string

	for _, file := range files {
		if strings.HasSuffix(file.Name(), "-tunnel.sock") {
			tunnelFiles = append(tunnelFiles, file.Name())
		}
	}

	logger.Debug("Tunnel socket files", "files", tunnelFiles)

	if len(tunnelFiles) > 1 {
		return "", fmt.Errorf("multiple bastion host IDs found in the tunnel directory %s. Likely due to abnormal termination before. Please clean up manually", tunnelDir)
	}

	if len(tunnelFiles) == 1 {
		bastionHostID := strings.TrimSuffix(tunnelFiles[0], "-tunnel.sock")
		return bastionHostID, nil
	}

	// TODO: attempt to get it from ssm processes

	return "", fmt.Errorf("no bastion host ID found in the tunnel directory")
}
